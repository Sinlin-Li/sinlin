<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>金蛋解谜纪念品</title>
      <link href="/posts/3648086945.html"/>
      <url>/posts/3648086945.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>【GoldenEggs 百万粉丝-解谜挑战】<br>第0题：<br>我们将一串数字以高级弹幕的形式发在了这片大地。<br>在群山之巅，在扁舟之涧；<br>在进化边境之外，在金色三角之中；<br>在盘根错节的星与海，在重力倒覆的不可期；<br>在虚实交界线的午夜狂欢，在孤岛逢生后的相见恨晚。<br>以时光为序，质素为基，可得二解；<br>其一为群；<br>其二为1bC3A2aBedc4EFD</p></blockquote><p><s>这是发生在2021.12.01的事情。</s></p><p>解谜的早期环节发现网上很多质因数分解器数字大一点就会输出错误的结果，比如说奇数分解出了2。活动举办方之后赶紧提供了一个正确的分解器hhh</p><p>活动里得到的奖品</p><p><img src="https://ooo.0x0.ooo/2023/10/31/ONkMwI.jpg" alt="goldenegg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 解谜, 纪念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的ACM模板</title>
      <link href="/posts/1694384414.html"/>
      <url>/posts/1694384414.html</url>
      
        <content type="html"><![CDATA[<h1 align="center"><font size="6">Sinlin的ACM模板</font></h1><div align='center'><font size="4">枚举 模拟 递归 分治 贪心 排序 前缀和 差分 二分 倍增 构造</font></div><h3 id="基本模板">基本模板</h3><pre><code class="language-cpp">#pragma GCC optimize(&quot;O2,inline,unroll-all-loops,no-stack-protector&quot;)// #pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native&quot;)#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;deque&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;limits&gt;#include &lt;map&gt;#include &lt;numeric&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#if __cplusplus &gt;= 201103L#include &lt;array&gt;#include &lt;chrono&gt;#include &lt;random&gt;#include &lt;tuple&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#endif#define ll long long#define ull unsigned long long#define pii pair&lt;int, int&gt;#define all(v) (v).begin(), (v).end()#define rall(v) (v).rbegin(), (v).rend()#define gsize(x) (int)((x).size())#define mp make_pair#define pb push_back#define MOD 998244353#define MOD2 1000000007#define nl '\n'#define endl '\n' // 交互题要删掉#define x first#define y secondusing namespace std;#ifdef LOCAL#define dmp(x) cerr &lt;&lt; &quot;DEBUG&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;:&quot; &lt;&lt; (#x) &lt;&lt; &quot; &quot; &lt;&lt; (x) &lt;&lt; endl#else#define dmp(x) void(0)#endiftemplate &lt;typename T&gt;void chkmin(T &amp;x, T y)    &#123;if (x &gt; y)  x = y;&#125;template &lt;typename T&gt;void chkmax(T &amp;x, T y)    &#123;if (x &lt; y)  x = y;&#125;template &lt;typename T1, typename T2&gt;ostream &amp;operator&lt;&lt;(ostream &amp;s, pair&lt;T1, T2&gt; &amp;p) &#123; return s &lt;&lt; &quot;&#123;&quot; &lt;&lt; p.first &lt;&lt; &quot;,&quot; &lt;&lt; p.second &lt;&lt; &quot;&#125;&quot;; &#125;const int N = 2e6 + 10;int a[N];void solve()&#123;    int n;    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++)    &#123;        cin &gt;&gt; a[i];    &#125;&#125;signed main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    cin.exceptions(cin.failbit);    int tc;    cin &gt;&gt; tc;    while (tc--)    &#123;        solve();    &#125;    return 0;&#125;</code></pre><h3 id="基础算法">基础算法</h3><h4 id="二维前缀和">二维前缀和</h4><p>S[i, j] = 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</p><h4 id="二维差分">二维差分</h4><p>给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c</p><h4 id="位运算">位运算</h4><p>求n的第k位数字: n &gt;&gt; k &amp; 1<br>返回n的最后一位1：lowbit(n) = n &amp; -n</p><h4 id="双指针算法">双指针算法</h4><p>常见问题分类：<br>(1) 对于一个序列，用两个指针维护一段区间<br>(2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</p><pre><code class="language-cpp">for (int i = 0, j = 0; i &lt; n; i ++ )&#123;    while (j &lt; i &amp;&amp; check(i, j)) j ++ ;    // 具体问题的逻辑&#125;</code></pre><h4 id="离散化">离散化</h4><pre><code class="language-cpp">vector&lt;int&gt; alls; // 存储所有待离散化的值sort(alls.begin(), alls.end()); // 将所有值排序alls.resize(unique(alls.begin(), alls.end()) - alls.begin());   // 去掉重复元素inline int find(int x)&#123;    return lower_bound(alls.begin(), alls.end(),x)-alls.begin()+1;&#125;</code></pre><h4 id="区间合并">区间合并</h4><pre><code class="language-cpp">// 将所有存在交集的区间合并void merge(vector&lt;PII&gt; &amp;segs)&#123;    vector&lt;PII&gt; res;    sort(segs.begin(), segs.end());    int st = -2e9, ed = -2e9;    for (auto seg : segs)        if (ed &lt; seg.first)        &#123;            if (st != -2e9) res.push_back(&#123;st, ed&#125;);            st = seg.first, ed = seg.second;        &#125;        else ed = max(ed, seg.second);    if (st != -2e9) res.push_back(&#123;st, ed&#125;);    segs = res;&#125;</code></pre><h4 id="单调栈">单调栈</h4><p>常见模型：找出每个数左边离它最近的比它大/小的数</p><pre><code class="language-cpp">int tt = 0;for (int i = 1; i &lt;= n; i ++ )&#123;    while (tt &amp;&amp; check(stk[tt], i)) tt -- ;    stk[ ++ tt] = i;&#125;</code></pre><h4 id="单调队列">单调队列</h4><p>常见模型：找出滑动窗口中的最大值/最小值</p><pre><code class="language-cpp">int hh = 0, tt = -1;for (int i = 0; i &lt; n; i ++ )&#123;    while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口    while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;    q[ ++ tt] = i;&#125;</code></pre><h4 id="排序">排序</h4><ul><li>快速排序</li></ul><pre><code class="language-cpp">void quick_sort(int q[], int l, int r)&#123;    if (l &gt;= r) return;    int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];    while (i &lt; j)    &#123;        do i ++ ; while (q[i] &lt; x);        do j -- ; while (q[j] &gt; x);        if (i &lt; j) swap(q[i], q[j]);    &#125;    quick_sort(q, l, j), quick_sort(q, j + 1, r);&#125;</code></pre><ul><li>归并排序</li></ul><pre><code class="language-cpp">void merge_sort(int q[], int l, int r)&#123;    if (l &gt;= r) return;    int mid = l + r &gt;&gt; 1;    merge_sort(q, l, mid);    merge_sort(q, mid + 1, r);    int k = 0, i = l, j = mid + 1;    while (i &lt;= mid &amp;&amp; j &lt;= r)        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];        else tmp[k ++ ] = q[j ++ ];    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];&#125;</code></pre><h3 id="字符串">字符串</h3><h4 id="KMP">KMP</h4><pre><code class="language-cpp">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度求模式串的Next数组：for (int i = 2, j = 0; i &lt;= m; i ++ )&#123;    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];    if (p[i] == p[j + 1]) j ++ ;    ne[i] = j;&#125;// 匹配for (int i = 1, j = 0; i &lt;= n; i ++ )&#123;    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];    if (s[i] == p[j + 1]) j ++ ;    if (j == m)    &#123;        j = ne[j];        // 匹配成功后的逻辑    &#125;&#125;</code></pre><h4 id="Trie树">Trie树</h4><pre><code class="language-cpp">int son[N][26], cnt[N], idx;// 0号点既是根节点，又是空节点// son[][]存储树中每个节点的子节点// cnt[]存储以每个节点结尾的单词数量// 插入一个字符串void insert(char *str)&#123;    int p = 0;    for (int i = 0; str[i]; i ++ )    &#123;        int u = str[i] - 'a';        if (!son[p][u]) son[p][u] = ++ idx;        p = son[p][u];    &#125;    cnt[p] ++ ;&#125;// 查询字符串出现的次数int query(char *str)&#123;    int p = 0;    for (int i = 0; str[i]; i ++ )    &#123;        int u = str[i] - 'a';        if (!son[p][u]) return 0;        p = son[p][u];    &#125;    return cnt[p];&#125;</code></pre><h4 id="字符串哈希">字符串哈希</h4><p>核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低<br>取模的数用2^64，这样直接用unsigned long long自然溢出的结果就是取模的结果</p><pre><code class="language-cpp">typedef pair&lt;int, int&gt; pii;struct Hash &#123;    int p, MOD, pp[N];    int pre[N];    Hash(int P, int mod) : p(P), MOD(mod) &#123;&#125;    void init(string &amp;s)    &#123;        int n = s.size();        pp[0] = 1;        for (int i = 1; i &lt;= n; i++)        &#123;            pp[i] = pp[i - 1] * p % MOD;            pre[i] = (pre[i - 1] * p + s[i - 1]) % MOD;        &#125;    &#125;    int hash(int l, int r) // 下标从1开始    &#123;        return (pre[r] - pre[l - 1] * pp[r - l + 1] % MOD + MOD) % MOD;    &#125;&#125; hs1(233, 998244353), hs2(1331, 1000000007);</code></pre><h4 id="manacher">manacher</h4><pre><code class="language-cpp">const int N = 2e7 + 10;char a[N];char s[N&lt;&lt;1];int p[N&lt;&lt;1];int n;void init()&#123;    int k=0;    s[k++]='$',s[k++]='#';    for(int i=0;i&lt;n;i++)    &#123;        s[k++]=a[i],s[k++]='#';    &#125;    s[k++]='^';    n=k;&#125;void manacher()&#123;    init();    int mr=0,mid;     for(int i=1;i&lt;n;i++)    &#123;        if(i&lt;mr)        &#123;            p[i]=min(p[mid*2-i],mr-i);            // if(p[mid*2-i]!=mr-i)            // &#123;                   //不需要扩展            //     goto B;            // &#125;        &#125;        else p[i]=1;        while(s[i-p[i]]==s[i+p[i]]) p[i]++;        // B:        if(i+p[i]&gt;mr)        &#123;            mr= i+p[i];            mid=i;        &#125;    &#125;&#125;</code></pre><h4 id="后缀自动机">后缀自动机</h4><p>一、SAM的性质:</p><pre><code>SAM是个状态机。一个起点，若干终点。原串的所有子串和从SAM起点开始的所有路径一一对应，不重不漏。所以终点就是包含后缀的点。每个点包含若干子串，每个子串都一一对应一条从起点到该点的路径。且这些子串一定是里面最长子串的连续后缀。SAM问题中经常考虑两种边：(1) 普通边，类似于Trie。表示在某个状态所表示的所有子串的后面添加一个字符。(2) Link、Father。表示将某个状态所表示的最短子串的首字母删除。这类边构成一棵树。</code></pre><p>二、SAM的构造思路</p><pre><code>endpos(s)：子串s所有出现的位置（尾字母下标）集合。SAM中的每个状态都一一对应一个endpos的等价类。endpos的性质：(1) 令 s1,s2 为 S 的两个子串 ，不妨设 |s1|≤|s2| （我们用 |s| 表示 s 的长度 ，此处等价于 s1 不长于 s2 ）。则 s1 是 s2 的后缀当且仅当 endpos(s1)⊇endpos(s2) ，s1 不是 s2 的后缀当且仅当 endpos(s1)∩endpos(s2)=∅　。(2) 两个不同子串的endpos，要么有包含关系，要么没有交集。(3) 两个子串的endpos相同，那么短串为长串的后缀。(4) 对于一个状态 st ，以及任意的 longest(st) 的后缀 s ，如果 s 的长度满足：|shortest(st)|≤|s|≤|longsest(st)| ，那么 s∈substrings(st) 。</code></pre><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 2000010;int tot = 1, last = 1;struct Node&#123;    int len, fa;    int ch[26];&#125;node[N];char str[N];LL f[N], ans;int h[N], e[N], ne[N], idx;void extend(int c)&#123;    int p = last, np = last = ++ tot;    f[tot] = 1;    node[np].len = node[p].len + 1;    for (; p &amp;&amp; !node[p].ch[c]; p = node[p].fa) node[p].ch[c] = np;    if (!p) node[np].fa = 1;    else    &#123;        int q = node[p].ch[c];        if (node[q].len == node[p].len + 1) node[np].fa = q;        else        &#123;            int nq = ++ tot;            node[nq] = node[q], node[nq].len = node[p].len + 1;            node[q].fa = node[np].fa = nq;            for (; p &amp;&amp; node[p].ch[c] == q; p = node[p].fa) node[p].ch[c] = nq;        &#125;    &#125;&#125;void add(int a, int b)&#123;    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;void dfs(int u)&#123;    for (int i = h[u]; ~i; i = ne[i])    &#123;        dfs(e[i]);        f[u] += f[e[i]];    &#125;    if (f[u] &gt; 1) ans = max(ans, f[u] * node[u].len);&#125;int main()&#123;    scanf(&quot;%s&quot;, str);    for (int i = 0; str[i]; i ++ ) extend(str[i] - 'a');    memset(h, -1, sizeof h);    for (int i = 2; i &lt;= tot; i ++ ) add(node[i].fa, i);    dfs(1);    printf(&quot;%lld\n&quot;, ans);    return 0;&#125;</code></pre><h4 id="最小表示法">最小表示法</h4><pre><code class="language-cpp">using namespace std;const int N = 2000010;int n;char a[N];int get_min(char s[])&#123;    int i = 0, j = 1;    while (i &lt; n &amp;&amp; j &lt; n)    &#123;        int k = 0;        while (k &lt; n &amp;&amp; s[i + k] == s[j + k]) k ++ ;        if (k == n) break;        if (s[i + k] &gt; s[j + k]) i += k + 1;        else j += k + 1;        if (i == j) j ++ ;    &#125;    int k = min(i, j);    s[k + n] = 0;    return k;&#125;    scanf(&quot;%s&quot;, a);    n = strlen(a);    memcpy(a + n, a, n);    int x = get_min(a);</code></pre><h3 id="图论">图论</h3><h4 id="邻接表">邻接表</h4><pre><code class="language-cpp">int h[N], e[N], ne[N], idx;// 添加一条边a-&gt;bvoid add(int a, int b)&#123;    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;// 初始化idx = 0;memset(h, -1, sizeof h);</code></pre><h4 id="拓扑排序">拓扑排序</h4><pre><code class="language-cpp">bool topsort()&#123;    int hh = 0, tt = -1;    // d[i] 存储点i的入度    for (int i = 1; i &lt;= n; i ++ )        if (!d[i])            q[ ++ tt] = i;    while (hh &lt;= tt)    &#123;        int t = q[hh ++ ];        for (int i = h[t]; i != -1; i = ne[i])        &#123;            int j = e[i];            if (-- d[j] == 0)                q[ ++ tt] = j;        &#125;    &#125;    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。    return tt == n - 1;&#125;</code></pre><h4 id="朴素dijkstra算法">朴素dijkstra算法</h4><p>时间复杂度 O(n^2+m)</p><pre><code class="language-cpp">int g[N][N];  // 存储每条边int dist[N];  // 存储1号点到每个点的最短距离bool st[N];   // 存储每个点的最短路是否已经确定// 求1号点到n号点的最短路，如果不存在则返回-1int dijkstra()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    for (int i = 0; i &lt; n - 1; i ++ )    &#123;        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点        for (int j = 1; j &lt;= n; j ++ )            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))                t = j;        // 用t更新其他点的距离        for (int j = 1; j &lt;= n; j ++ )            dist[j] = min(dist[j], dist[t] + g[t][j]);        st[t] = true;    &#125;    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];&#125;</code></pre><h4 id="堆优化版dijkstra">堆优化版dijkstra</h4><p>时间复杂度 O(mlogn)</p><pre><code class="language-cpp">typedef pair&lt;int, int&gt; PII;int n;      // 点的数量int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边int dist[N];        // 存储所有点到1号点的距离bool st[N];     // 存储每个点的最短距离是否已确定// 求1号点到n号点的最短距离，如果不存在，则返回-1int dijkstra()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;    heap.push(&#123;0, 1&#125;);      // first存储距离，second存储节点编号    while (heap.size())    &#123;        auto t = heap.top();        heap.pop();        int ver = t.second, distance = t.first;        if (st[ver]) continue;        st[ver] = true;        for (int i = h[ver]; i != -1; i = ne[i])        &#123;            int j = e[i];            if (dist[j] &gt; distance + w[i])            &#123;                dist[j] = distance + w[i];                heap.push(&#123;dist[j], j&#125;);            &#125;        &#125;    &#125;    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];&#125;</code></pre><h4 id="Bellman-Ford算法-——-有边数限制的最短路">Bellman-Ford算法 —— 有边数限制的最短路</h4><p>时间复杂度 O(nm)</p><pre><code class="language-cpp">注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。int n, m;       // n表示点数，m表示边数int dist[N];        // dist[x]存储1到x的最短路距离struct Edge     // 边，a表示出点，b表示入点，w表示边的权重&#123;    int a, b, w;&#125;edges[M];// 求1到n的最短路距离，如果无法从1走到n，则返回-1。int bellman_ford()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。    for (int i = 0; i &lt; n; i ++ )    &#123;        for (int j = 0; j &lt; m; j ++ )        &#123;            int a = edges[j].a, b = edges[j].b, w = edges[j].w;            if (dist[b] &gt; dist[a] + w)                dist[b] = dist[a] + w;        &#125;    &#125;    if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;    return dist[n];&#125;</code></pre><h4 id="spfa-算法（队列优化的Bellman-Ford算法）">spfa 算法（队列优化的Bellman-Ford算法）</h4><p>时间复杂度 平均情况下 O(m)</p><pre><code class="language-cpp">int n;      // 总点数int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边int dist[N];        // 存储每个点到1号点的最短距离bool st[N];     // 存储每个点是否在队列中// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1int spfa()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    queue&lt;int&gt; q;    q.push(1);    st[1] = true;    while (q.size())    &#123;        auto t = q.front();        q.pop();        st[t] = false;        for (int i = h[t]; i != -1; i = ne[i])        &#123;            int j = e[i];            if (dist[j] &gt; dist[t] + w[i])            &#123;                dist[j] = dist[t] + w[i];                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入                &#123;                    q.push(j);                    st[j] = true;                &#125;            &#125;        &#125;    &#125;    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];&#125;</code></pre><h4 id="spfa判断图中是否存在负环">spfa判断图中是否存在负环</h4><p>时间复杂度是 O(nm)</p><pre><code class="language-cpp">int n;      // 总点数int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边int dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数bool st[N];     // 存储每个点是否在队列中// 如果存在负环，则返回true，否则返回false。bool spfa()&#123;    // 不需要初始化dist数组    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。    queue&lt;int&gt; q;    for (int i = 1; i &lt;= n; i ++ )    &#123;        q.push(i);        st[i] = true;    &#125;    while (q.size())    &#123;        auto t = q.front();        q.pop();        st[t] = false;        for (int i = h[t]; i != -1; i = ne[i])        &#123;            int j = e[i];            if (dist[j] &gt; dist[t] + w[i])            &#123;                dist[j] = dist[t] + w[i];                cnt[j] = cnt[t] + 1;                if (cnt[j] &gt;= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环                if (!st[j])                &#123;                    q.push(j);                    st[j] = true;                &#125;            &#125;        &#125;    &#125;    return false;&#125;</code></pre><h4 id="floyd算法">floyd算法</h4><pre><code class="language-cpp">//初始化：    for (int i = 1; i &lt;= n; i ++ )        for (int j = 1; j &lt;= n; j ++ )            if (i == j) d[i][j] = 0;            else d[i][j] = INF;// 算法结束后，d[a][b]表示a到b的最短距离void floyd()&#123;    for (int k = 1; k &lt;= n; k ++ )        for (int i = 1; i &lt;= n; i ++ )            for (int j = 1; j &lt;= n; j ++ )                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);&#125;</code></pre><h4 id="朴素版prim算法">朴素版prim算法</h4><p>时间复杂度是 O(n^2+m)</p><pre><code class="language-cpp">int n;      // n表示点数int g[N][N];        // 邻接矩阵，存储所有边int dist[N];        // 存储其他点到当前最小生成树的距离bool st[N];     // 存储每个点是否已经在生成树中// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和int prim()&#123;    memset(dist, 0x3f, sizeof dist);    int res = 0;    for (int i = 0; i &lt; n; i ++ )    &#123;        int t = -1;        for (int j = 1; j &lt;= n; j ++ )            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))                t = j;        if (i &amp;&amp; dist[t] == INF) return INF;        if (i) res += dist[t];        st[t] = true;        for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);    &#125;    return res;&#125;</code></pre><h4 id="Kruskal算法-——-求最小生成树">Kruskal算法 —— 求最小生成树</h4><p>时间复杂度是 O(mlogm)</p><pre><code class="language-cpp">int n, m;       // n是点数，m是边数int p[N];       // 并查集的父节点数组struct Edge     // 存储边&#123;    int a, b, w;    bool operator&lt; (const Edge &amp;W)const    &#123;        return w &lt; W.w;    &#125;&#125;edges[M];int find(int x)     // 并查集核心操作&#123;    if (p[x] != x) p[x] = find(p[x]);    return p[x];&#125;int kruskal()&#123;    sort(edges, edges + m);    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // 初始化并查集    int res = 0, cnt = 0;    for (int i = 0; i &lt; m; i ++ )    &#123;        int a = edges[i].a, b = edges[i].b, w = edges[i].w;        a = find(a), b = find(b);        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并        &#123;            p[a] = b;            res += w;            cnt ++ ;        &#125;    &#125;    if (cnt &lt; n - 1) return INF;    return res;&#125;</code></pre><h4 id="染色法判别二分图">染色法判别二分图</h4><pre><code class="language-cpp">int n;      // n表示点数int h[N], e[M], ne[M], idx;     // 邻接表存储图int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色// 参数：u表示当前节点，c表示当前点的颜色bool dfs(int u, int c)&#123;    color[u] = c;    for (int i = h[u]; i != -1; i = ne[i])    &#123;        int j = e[i];        if (color[j] == -1)        &#123;            if (!dfs(j, !c)) return false;        &#125;        else if (color[j] == c) return false;    &#125;    return true;&#125;bool check()&#123;    memset(color, -1, sizeof color);    bool flag = true;    for (int i = 1; i &lt;= n; i ++ )        if (color[i] == -1)            if (!dfs(i, 0))            &#123;                flag = false;                break;            &#125;    return flag;&#125;</code></pre><h4 id="匈牙利算法-——-二分图的最大匹配">匈牙利算法 —— 二分图的最大匹配</h4><p>时间复杂度是 O(nm)</p><pre><code class="language-cpp">int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数int h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个bool st[N];     // 表示第二个集合中的每个点是否已经被遍历过bool find(int x)&#123;    for (int i = h[x]; i != -1; i = ne[i])    &#123;        int j = e[i];        if (!st[j])        &#123;            st[j] = true;            if (match[j] == 0 || find(match[j]))            &#123;                match[j] = x;                return true;            &#125;        &#125;    &#125;    return false;&#125;// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点int res = 0;for (int i = 1; i &lt;= n1; i ++ )&#123;    memset(st, false, sizeof st);    if (find(i)) res ++ ;&#125;</code></pre><ul><li>试除法分解质因数</li></ul><pre><code class="language-CPP">void divide(int x)&#123;    for (int i = 2; i &lt;= x / i; i ++ )        if (x % i == 0)        &#123;            int s = 0;            while (x % i == 0) x /= i, s ++ ;            cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; s &lt;&lt; endl;        &#125;    if (x &gt; 1) cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; endl;    cout &lt;&lt; endl;&#125;</code></pre><h3 id="数论">数论</h3><h4 id="线性筛法求素数">线性筛法求素数</h4><pre><code class="language-cpp">int primes[N], cnt;     // primes[]存储所有素数bool st[N];         // st[x]存储x是否被筛掉void get_primes(int n)&#123;    for (int i = 2; i &lt;= n; i ++ )    &#123;        if (!st[i]) primes[cnt ++ ] = i;        for (int j = 0; primes[j] &lt;= n / i; j ++ )        &#123;            st[primes[j] * i] = true;            if (i % primes[j] == 0) break;        &#125;    &#125;&#125;</code></pre><h4 id="约数个数和约数之和">约数个数和约数之和</h4><p>如果 N = p1^c1 <em>p2^c2</em> … <em>pk^ck<br>约数个数： (c1 + 1)</em> (c2 + 1) <em>…</em> (ck + 1)<br>约数之和： (p1^0 + p1^1 + … + p1^c1) <em>…</em> (pk^0 + pk^1 + … + pk^ck)</p><h4 id="欧几里得算法">欧几里得算法</h4><pre><code class="language-cpp">int gcd(int a, int b)&#123;    return b ? gcd(b, a % b) : a;&#125;</code></pre><h4 id="扩展欧几里得算法">扩展欧几里得算法</h4><pre><code class="language-cpp">// 求x, y，使得ax + by = gcd(a, b)int exgcd(int a, int b, int &amp;x, int &amp;y)&#123;    if (!b)    &#123;        x = 1; y = 0;        return a;    &#125;    int d = exgcd(b, a % b, y, x);    y -= (a/b) * x;    return d;&#125;</code></pre><h4 id="求欧拉函数">求欧拉函数</h4><pre><code class="language-cpp">int phi(int x)&#123;    int res = x;    for (int i = 2; i &lt;= x / i; i ++ )        if (x % i == 0)        &#123;            res = res / i * (i - 1);            while (x % i == 0) x /= i;        &#125;    if (x &gt; 1) res = res / x * (x - 1);    return res;&#125;</code></pre><h4 id="筛法求欧拉函数">筛法求欧拉函数</h4><pre><code class="language-cpp">int primes[N], cnt;     // primes[]存储所有素数int euler[N];           // 存储每个数的欧拉函数bool st[N];         // st[x]存储x是否被筛掉void get_eulers(int n)&#123;    euler[1] = 1;    for (int i = 2; i &lt;= n; i ++ )    &#123;        if (!st[i])        &#123;            primes[cnt ++ ] = i;            euler[i] = i - 1;        &#125;        for (int j = 0; primes[j] &lt;= n / i; j ++ )        &#123;            int t = primes[j] * i;            st[t] = true;            if (i % primes[j] == 0)            &#123;                euler[t] = euler[i] * primes[j];                break;            &#125;            euler[t] = euler[i] * (primes[j] - 1);        &#125;    &#125;&#125;</code></pre><h4 id="高斯消元">高斯消元</h4><pre><code class="language-cpp">// a[N][N]是增广矩阵int gauss()&#123;    int c, r;    for (c = 0, r = 0; c &lt; n; c ++ )    &#123;-        int t = r;        for (int i = r; i &lt; n; i ++ )   // 找到绝对值最大的行            if (fabs(a[i][c]) &gt; fabs(a[t][c]))                t = i;        if (fabs(a[t][c]) &lt; eps) continue;        for (int i = c; i &lt;= n; i ++ ) swap(a[t][i], a[r][i]);      // 将绝对值最大的行换到最顶端        for (int i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];      // 将当前行的首位变成1        for (int i = r + 1; i &lt; n; i ++ )       // 用当前行将下面所有的列消成0            if (fabs(a[i][c]) &gt; eps)                for (int j = n; j &gt;= c; j -- )                    a[i][j] -= a[r][j] * a[i][c];        r ++ ;    &#125;    if (r &lt; n)    &#123;        for (int i = r; i &lt; n; i ++ )            if (fabs(a[i][n]) &gt; eps)                return 2; // 无解        return 1; // 有无穷多组解    &#125;    for (int i = n - 1; i &gt;= 0; i -- )        for (int j = i + 1; j &lt; n; j ++ )            a[i][n] -= a[i][j] * a[j][n];    return 0; // 有唯一解&#125;</code></pre><h4 id="递推法求组合数">递推法求组合数</h4><pre><code class="language-cpp">// c[a][b] 表示从a个苹果中选b个的方案数for (int i = 0; i &lt; N; i ++ )    for (int j = 0; j &lt;= i; j ++ )        if (!j) c[i][j] = 1;        else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % MOD;</code></pre><h4 id="通过预处理逆元的方式求组合数">通过预处理逆元的方式求组合数</h4><p>首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]<br>如果取模的数是质数，可以用费马小定理求逆元</p><pre><code class="language-cpp">int qmi(int a, int k, int p)    // 快速幂模板&#123;    int res = 1;    while (k)    &#123;        if (k &amp; 1) res = (ll)res * a % p;        a = (ll)a * a % p;        k &gt;&gt;= 1;    &#125;    return res;&#125;// 预处理阶乘的余数和阶乘逆元的余数fact[0] = infact[0] = 1;for (int i = 1; i &lt; N; i ++ )&#123;    fact[i] = (ll)fact[i - 1] * i % MOD;    infact[i] = (ll)infact[i - 1] * qmi(i, MOD - 2, MOD) % MOD; //递推求逆元更快&#125;</code></pre><h4 id="Lucas定理">Lucas定理</h4><p>若p是质数，则对于任意整数 1 &lt;= m &lt;= n，有：<br>C(n, m) = C(n % p, m % p) * C(n / p, m / p) (MOD p)</p><pre><code class="language-cpp">int qmi(int a, int k, int p)  // 快速幂模板&#123;    int res = 1 % p;    while (k)    &#123;        if (k &amp; 1) res = (ll)res * a % p;        a = (ll)a * a % p;        k &gt;&gt;= 1;    &#125;    return res;&#125;int C(int a, int b, int p)  // 通过定理求组合数C(a, b)&#123;    if (a &lt; b) return 0;    ll x = 1, y = 1;  // x是分子，y是分母    for (int i = a, j = 1; j &lt;= b; i --, j ++ )    &#123;        x = (ll)x * i % p;        y = (ll) y * j % p;    &#125;    return x * (ll)qmi(y, p - 2, p) % p;&#125;int lucas(ll a, ll b, int p)&#123;    if (a &lt; p &amp;&amp; b &lt; p) return C(a, b, p);    return (ll)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;&#125;</code></pre><h4 id="分解质因数法求组合数">分解质因数法求组合数</h4><p>当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：</p><ol><li>筛法求出范围内的所有质数</li><li>通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + …</li><li>用高精度乘法将所有质因子相乘</li></ol><pre><code class="language-cpp">int primes[N], cnt;     // 存储所有质数int sum[N];     // 存储每个质数的次数bool st[N];     // 存储每个数是否已被筛掉void get_primes(int n)      // 线性筛法求素数&#123;    for (int i = 2; i &lt;= n; i ++ )    &#123;        if (!st[i]) primes[cnt ++ ] = i;        for (int j = 0; primes[j] &lt;= n / i; j ++ )        &#123;            st[primes[j] * i] = true;            if (i % primes[j] == 0) break;        &#125;    &#125;&#125;int get(int n, int p)       // 求n！中的次数&#123;    int res = 0;    while (n)    &#123;        res += n / p;        n /= p;    &#125;    return res;&#125;vector&lt;int&gt; mul(vector&lt;int&gt; a, int b)       // 高精度乘低精度模板&#123;    vector&lt;int&gt; c;    int t = 0;    for (int i = 0; i &lt; a.size(); i ++ )    &#123;        t += a[i] * b;        c.push_back(t % 10);        t /= 10;    &#125;    while (t)    &#123;        c.push_back(t % 10);        t /= 10;    &#125;    return c;&#125;get_primes(a);  // 预处理范围内的所有质数for (int i = 0; i &lt; cnt; i ++ )     // 求每个质因数的次数&#123;    int p = primes[i];    sum[i] = get(a, p) - get(b, p) - get(a - b, p);&#125;vector&lt;int&gt; res;res.push_back(1);for (int i = 0; i &lt; cnt; i ++ )     // 用高精度乘法将所有质因子相乘    for (int j = 0; j &lt; sum[i]; j ++ )        res = mul(res, primes[i]);</code></pre><h4 id="卡特兰数-——-满足条件的01序列">卡特兰数 —— 满足条件的01序列</h4><p>给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) = C(2n, n) / (n + 1)</p><h3 id="博弈论">博弈论</h3><h4 id="NIM游戏">NIM游戏</h4><p>定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0</p><h4 id="公平组合游戏ICG">公平组合游戏ICG</h4><p>若一个游戏满足：<br>由两名玩家交替行动；<br>在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；<br>不能行动的玩家判负；<br>则称该游戏为一个公平组合游戏。<br>NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。</p><h4 id="有向图游戏">有向图游戏</h4><p>给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。<br>任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。</p><h5 id="有向图游戏的和-——-模板题-AcWing-893-集合-Nim游戏">有向图游戏的和 —— 模板题 AcWing 893. 集合-Nim游戏</h5><p>设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。<br>有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：<br>SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)</p><h5 id="定理">定理</h5><p>有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。<br>有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。</p><h3 id="数据结构">数据结构</h3><h4 id="并查集">并查集</h4><ul><li>维护size的并查集</li></ul><pre><code class="language-cpp">int p[N], size[N];//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量int find(int x)&#123;    if (p[x] != x) p[x] = find(p[x]);    return p[x];&#125;for (int i = 1; i &lt;= n; i ++ )&#123;    p[i] = i;    size[i] = 1;&#125;size[find(b)] += size[find(a)];p[find(a)] = find(b);</code></pre><ul><li>维护到祖宗节点距离的并查集</li></ul><pre><code class="language-cpp">int p[N], d[N];//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离int find(int x)&#123;    if (p[x] != x)    &#123;        int u = find(p[x]);        d[x] += d[p[x]];        p[x] = u;    &#125;    return p[x];&#125;for (int i = 1; i &lt;= n; i ++ )&#123;    p[i] = i;    d[i] = 0;&#125;p[find(a)] = find(b);d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量</code></pre><h4 id="ST表">ST表</h4><p>M取ceil(log(2))</p><pre><code class="language-cpp">int n, m;int w[N];int f[N][M];void init()&#123;    for (int j = 0; j &lt; M; j ++ )        for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i ++ )            if (!j) f[i][j] = w[i];            else f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; j - 1)][j - 1]);&#125;int query(int l, int r)&#123;    int len = r - l + 1;    int k = log(len) / log(2);    return max(f[l][k], f[r - (1 &lt;&lt; k) + 1][k]);&#125;</code></pre><h4 id="树状数组——注意下标从1开始">树状数组——注意下标从1开始</h4><pre><code class="language-cpp">int n;int a[N];int tr[N];memset(tr, 0, sizeof tr);int lowbit(int x)&#123;    return x &amp; -x;&#125;void add(int x, int c)&#123;    for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c;&#125;int sum(int x)&#123;    int res = 0;    for (int i = x; i; i -= lowbit(i)) res += tr[i];    return res;&#125;//线性构造int pre[N]void init()&#123;    for (int i = 1; i &lt;= n; i++)&#123;        pre[i] = pre[i - 1] + a[i];        tr[i] = pre[i] - pre[i - lowbit(i)];    &#125;&#125;</code></pre><h4 id="线段树">线段树</h4><h5 id="区间改区间查">区间改区间查</h5><pre><code class="language-cpp">int n, m;int w[N];struct Node&#123;    int l, r;    ll sum, add;&#125;tr[N * 4];void pushup(int u)&#123;    tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;&#125;void pushdown(int u)&#123;    auto &amp;root = tr[u], &amp;left = tr[u &lt;&lt; 1], &amp;right = tr[u &lt;&lt; 1 | 1];    if (root.add)    &#123;        left.add += root.add, left.sum += (ll)(left.r - left.l + 1) * root.add;        right.add += root.add, right.sum += (ll)(right.r - right.l + 1) * root.add;        root.add = 0;    &#125;&#125;void build(int u, int l, int r)&#123;    if (l == r) tr[u] = &#123;l, r, w[r], 0&#125;;    else    &#123;        tr[u] = &#123;l, r&#125;;        int mid = l + r &gt;&gt; 1;        build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);        pushup(u);    &#125;&#125;void MODify(int u, int l, int r, int d)&#123;    if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)    &#123;        tr[u].sum += (ll)(tr[u].r - tr[u].l + 1) * d;        tr[u].add += d;    &#125;    else    // 一定要分裂    &#123;        pushdown(u);        int mid = tr[u].l + tr[u].r &gt;&gt; 1;        if (l &lt;= mid) MODify(u &lt;&lt; 1, l, r, d);        if (r &gt; mid) MODify(u &lt;&lt; 1 | 1, l, r, d);        pushup(u);    &#125;&#125;ll query(int u, int l, int r)&#123;    if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum;    pushdown(u);    int mid = tr[u].l + tr[u].r &gt;&gt; 1;    ll sum = 0;    if (l &lt;= mid) sum = query(u &lt;&lt; 1, l, r);    if (r &gt; mid) sum += query(u &lt;&lt; 1 | 1, l, r);    return sum;&#125;int main()&#123;    build(1, 1, n);&#125;</code></pre><h5 id="单点查区间改">单点查区间改</h5><pre><code class="language-cpp">int a[N];struct Node&#123;    int l, r;    int v;&#125; tr[N * 4];void pushup(int u) // 由子节点的信息，来计算父节点的信息&#123;    tr[u].v = tr[u &lt;&lt; 1].v + tr[u &lt;&lt; 1 | 1].v;&#125;void build(int u, int l, int r)&#123;    tr[u] = &#123;l, r&#125;;    if (l == r)        return;    int mid = l + r &gt;&gt; 1;    build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);&#125;int query(int u, int l, int r)&#123;    if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)        return tr[u].v; // 树中节点，已经被完全包含在[l, r]中了    int mid = tr[u].l + tr[u].r &gt;&gt; 1;    int v = 0;    if (l &lt;= mid)        v = query(u &lt;&lt; 1, l, r);    if (r &gt; mid)        v = v + query(u &lt;&lt; 1 | 1, l, r);    return v;&#125;void MODify(int u, int x, int v)&#123;    if (tr[u].l == x &amp;&amp; tr[u].r == x)        tr[u].v += v;    else    &#123;        int mid = tr[u].l + tr[u].r &gt;&gt; 1;        if (x &lt;= mid)            MODify(u &lt;&lt; 1, x, v);        else            MODify(u &lt;&lt; 1 | 1, x, v);        pushup(u);    &#125;&#125;int main()&#123;    build(1, 1, n);&#125;</code></pre><h4 id="主席树——第k小">主席树——第k小</h4><pre><code class="language-cpp">int n, m;int a[N];vector&lt;int&gt; nums;struct Node&#123;    int l, r;    int cnt;&#125;tr[N * 4 + N * 17];int root[N], idx;int find(int x)&#123;    return lower_bound(nums.begin(), nums.end(), x) - nums.begin();&#125;int build(int l, int r)&#123;    int p = ++ idx;    if (l == r) return p;    int mid = l + r &gt;&gt; 1;    tr[p].l = build(l, mid), tr[p].r = build(mid + 1, r);    return p;&#125;int insert(int p, int l, int r, int x)&#123;    int q = ++ idx;    tr[q] = tr[p];    if (l == r)    &#123;        tr[q].cnt ++ ;        return q;    &#125;    int mid = l + r &gt;&gt; 1;    if (x &lt;= mid) tr[q].l = insert(tr[p].l, l, mid, x);    else tr[q].r = insert(tr[p].r, mid + 1, r, x);    tr[q].cnt = tr[tr[q].l].cnt + tr[tr[q].r].cnt;    return q;&#125;int query(int q, int p, int l, int r, int k)&#123;    if (l == r) return r;    int cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt;    int mid = l + r &gt;&gt; 1;    if (k &lt;= cnt) return query(tr[q].l, tr[p].l, l, mid, k);    else return query(tr[q].r, tr[p].r, mid + 1, r, k - cnt);&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i ++ )    &#123;        scanf(&quot;%d&quot;, &amp;a[i]);        nums.push_back(a[i]);    &#125;    sort(nums.begin(), nums.end());    nums.erase(unique(nums.begin(), nums.end()), nums.end());    root[0] = build(0, nums.size() - 1);    for (int i = 1; i &lt;= n; i ++ )        root[i] = insert(root[i - 1], 0, nums.size() - 1, find(a[i]));    while (m -- )    &#123;        int l, r, k;        scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);        printf(&quot;%d\n&quot;, nums[query(root[r], root[l - 1], 0, nums.size() - 1, k)]);    &#125;    return 0;&#125;</code></pre><h4 id="Treap树">Treap树</h4><pre><code class="language-cpp">const int INF = 1e8;int n;struct Node&#123;    int l, r;    int key, val;    int cnt, size;&#125;tr[N];int root, idx;void pushup(int p)&#123;    tr[p].size = tr[tr[p].l].size + tr[tr[p].r].size + tr[p].cnt;&#125;int get_node(int key)&#123;    tr[ ++ idx].key = key;    tr[idx].val = rand();    tr[idx].cnt = tr[idx].size = 1;    return idx;&#125;void zig(int &amp;p)    // 右旋&#123;    int q = tr[p].l;    tr[p].l = tr[q].r, tr[q].r = p, p = q;    pushup(tr[p].r), pushup(p);&#125;void zag(int &amp;p)    // 左旋&#123;    int q = tr[p].r;    tr[p].r = tr[q].l, tr[q].l = p, p = q;    pushup(tr[p].l), pushup(p);&#125;void build()&#123;    get_node(-INF), get_node(INF);    root = 1, tr[1].r = 2;    pushup(root);    if (tr[1].val &lt; tr[2].val) zag(root);&#125;void insert(int &amp;p, int key)&#123;    if (!p) p = get_node(key);    else if (tr[p].key == key) tr[p].cnt ++ ;    else if (tr[p].key &gt; key)    &#123;        insert(tr[p].l, key);        if (tr[tr[p].l].val &gt; tr[p].val) zig(p);    &#125;    else    &#123;        insert(tr[p].r, key);        if (tr[tr[p].r].val &gt; tr[p].val) zag(p);    &#125;    pushup(p);&#125;void remove(int &amp;p, int key)&#123;    if (!p) return;    if (tr[p].key == key)    &#123;        if (tr[p].cnt &gt; 1) tr[p].cnt -- ;        else if (tr[p].l || tr[p].r)        &#123;            if (!tr[p].r || tr[tr[p].l].val &gt; tr[tr[p].r].val)            &#123;                zig(p);                remove(tr[p].r, key);            &#125;            else            &#123;                zag(p);                remove(tr[p].l, key);            &#125;        &#125;        else p = 0;    &#125;    else if (tr[p].key &gt; key) remove(tr[p].l, key);    else remove(tr[p].r, key);    pushup(p);&#125;int get_rank_by_key(int p, int key)    // 通过数值找排名&#123;    if (!p) return 0;   // 本题中不会发生此情况    if (tr[p].key == key) return tr[tr[p].l].size + 1;    if (tr[p].key &gt; key) return get_rank_by_key(tr[p].l, key);    return tr[tr[p].l].size + tr[p].cnt + get_rank_by_key(tr[p].r, key);&#125;int get_key_by_rank(int p, int rank)   // 通过排名找数值&#123;    if (!p) return INF;     // 本题中不会发生此情况    if (tr[tr[p].l].size &gt;= rank) return get_key_by_rank(tr[p].l, rank);    if (tr[tr[p].l].size + tr[p].cnt &gt;= rank) return tr[p].key;    return get_key_by_rank(tr[p].r, rank - tr[tr[p].l].size - tr[p].cnt);&#125;int get_prev(int p, int key)   // 找到严格小于key的最大数&#123;    if (!p) return -INF;    if (tr[p].key &gt;= key) return get_prev(tr[p].l, key);    return max(tr[p].key, get_prev(tr[p].r, key));&#125;int get_next(int p, int key)    // 找到严格大于key的最小数&#123;    if (!p) return INF;    if (tr[p].key &lt;= key) return get_next(tr[p].r, key);    return min(tr[p].key, get_next(tr[p].l, key));&#125;int main()&#123;    build();    scanf(&quot;%d&quot;, &amp;n);    while (n -- )    &#123;        int opt, x;        scanf(&quot;%d%d&quot;, &amp;opt, &amp;x);        if (opt == 1) insert(root, x);        else if (opt == 2) remove(root, x);        else if (opt == 3) printf(&quot;%d\n&quot;, get_rank_by_key(root, x) - 1);        else if (opt == 4) printf(&quot;%d\n&quot;, get_key_by_rank(root, x + 1));        else if (opt == 5) printf(&quot;%d\n&quot;, get_prev(root, x));        else printf(&quot;%d\n&quot;, get_next(root, x));    &#125;    return 0;&#125;</code></pre><h4 id="LCA">LCA</h4><pre><code class="language-cpp">int n, m;int h[N], e[M], ne[M], idx;int depth[N], fa[N][16];int q[N];void add(int a, int b)&#123;    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;void bfs(int root)&#123;    memset(depth, 0x3f, sizeof depth);    depth[0] = 0, depth[root] = 1;    int hh = 0, tt = 0;    q[0] = root;    while (hh &lt;= tt)    &#123;        int t = q[hh ++ ];        for (int i = h[t]; ~i; i = ne[i])        &#123;            int j = e[i];            if (depth[j] &gt; depth[t] + 1)            &#123;                depth[j] = depth[t] + 1;                q[ ++ tt] = j;                fa[j][0] = t;                for (int k = 1; k &lt;= 15; k ++ )                    fa[j][k] = fa[fa[j][k - 1]][k - 1];            &#125;        &#125;    &#125;&#125;int lca(int a, int b)&#123;    if (depth[a] &lt; depth[b]) swap(a, b);    for (int k = 15; k &gt;= 0; k -- )        if (depth[fa[a][k]] &gt;= depth[b])            a = fa[a][k];    if (a == b) return a;    for (int k = 15; k &gt;= 0; k -- )        if (fa[a][k] != fa[b][k])        &#123;            a = fa[a][k];            b = fa[b][k];        &#125;    return fa[a][0];&#125;memset(h, -1, sizeof h);bfs(root);</code></pre><h4 id="splay">splay</h4><h5 id="维护区间翻转">维护区间翻转</h5><p>编号从1开始</p><pre><code class="language-cpp">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n, m;struct Node&#123;    int s[2], p, v;    int size, flag;    void init(int _v, int _p)    &#123;        v = _v, p = _p;        size = 1;    &#125;&#125;tr[N];int root, idx;void pushup(int x)&#123;    tr[x].size = tr[tr[x].s[0]].size + tr[tr[x].s[1]].size + 1;&#125;void pushdown(int x)&#123;    if (tr[x].flag)    &#123;        swap(tr[x].s[0], tr[x].s[1]);        tr[tr[x].s[0]].flag ^= 1;        tr[tr[x].s[1]].flag ^= 1;        tr[x].flag = 0;    &#125;&#125;void rotate(int x)&#123;    int y = tr[x].p, z = tr[y].p;    int k = tr[y].s[1] == x;  // k=0表示x是y的左儿子；k=1表示x是y的右儿子    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;    tr[x].s[k ^ 1] = y, tr[y].p = x;    pushup(y), pushup(x);&#125;void splay(int x, int k)&#123;    while (tr[x].p != k)    &#123;        int y = tr[x].p, z = tr[y].p;        if (z != k)            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);            else rotate(y);        rotate(x);    &#125;    if (!k) root = x;&#125;void insert(int v)&#123;    int u = root, p = 0;    while (u) p = u, u = tr[u].s[v &gt; tr[u].v];    u = ++ idx;    if (p) tr[p].s[v &gt; tr[p].v] = u;    tr[u].init(v, p);    splay(u, 0);&#125;int get_k(int k)&#123;    int u = root;    while (true)    &#123;        pushdown(u);        if (tr[tr[u].s[0]].size &gt;= k) u = tr[u].s[0];        else if (tr[tr[u].s[0]].size + 1 == k) return u;        else k -= tr[tr[u].s[0]].size + 1, u = tr[u].s[1];    &#125;    return -1;&#125;void output(int u)&#123;    pushdown(u);    if (tr[u].s[0]) output(tr[u].s[0]);    if (tr[u].v &gt;= 1 &amp;&amp; tr[u].v &lt;= n) printf(&quot;%d &quot;, tr[u].v);    if (tr[u].s[1]) output(tr[u].s[1]);&#125;void flip(int l,r)&#123;    l = get_k(l), r = get_k(r + 2);    splay(l, 0), splay(r, l);    tr[tr[r].s[0]].flag ^= 1;&#125;//初始化for (int i = 0; i &lt;= n + 1; i ++ ) insert(i);flip(l,r);//输出结果output(root);</code></pre><h3 id="基本数据结构">基本数据结构</h3><h4 id="单链表">单链表</h4><pre><code class="language-cpp">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点int head, e[N], ne[N], idx;// 初始化void init()&#123;    head = -1;    idx = 0;&#125;// 在链表头插入一个数avoid insert(int a)&#123;    e[idx] = a, ne[idx] = head, head = idx ++ ;&#125;// 将头结点删除，需要保证头结点存在void remove()&#123;    head = ne[head];&#125;</code></pre><h4 id="双链表">双链表</h4><pre><code class="language-cpp">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点int e[N], l[N], r[N], idx;// 初始化void init()&#123;    //0是左端点，1是右端点    r[0] = 1, l[1] = 0;    idx = 2;&#125;// 在节点a的右边插入一个数xvoid insert(int a, int x)&#123;    e[idx] = x;    l[idx] = a, r[idx] = r[a];    l[r[a]] = idx, r[a] = idx ++ ;&#125;// 删除节点avoid remove(int a)&#123;    l[r[a]] = l[a];    r[l[a]] = r[a];&#125;</code></pre><h4 id="普通队列">普通队列</h4><pre><code class="language-cpp">// hh 表示队头，tt表示队尾int q[N], hh = 0, tt = -1;// 向队尾插入一个数q[ ++ tt] = x;// 从队头弹出一个数hh ++ ;// 队头的值q[hh];// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空if (hh &lt;= tt)&#123;&#125;</code></pre><h4 id="循环队列">循环队列</h4><pre><code class="language-cpp">// hh 表示队头，tt表示队尾的后一个位置int q[N], hh = 0, tt = 0;// 向队尾插入一个数q[tt ++ ] = x;if (tt == N) tt = 0;// 从队头弹出一个数hh ++ ;if (hh == N) hh = 0;// 队头的值q[hh];// 判断队列是否为空，如果hh != tt，则表示不为空if (hh != tt)&#123;&#125;</code></pre><h4 id="堆">堆</h4><pre><code class="language-cpp">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1// ph[k]存储第k个插入的点在堆中的位置// hp[k]存储堆中下标是k的点是第几个插入的int h[N], ph[N], hp[N], size;// 交换两个点，及其映射关系void heap_swap(int a, int b)&#123;    swap(ph[hp[a]],ph[hp[b]]);    swap(hp[a], hp[b]);    swap(h[a], h[b]);&#125;void down(int u)&#123;    int t = u;    if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;    if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;    if (u != t)    &#123;        heap_swap(u, t);        down(t);    &#125;&#125;void up(int u)&#123;    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])    &#123;        heap_swap(u, u / 2);        u &gt;&gt;= 1;    &#125;&#125;// O(n)建堆for (int i = n / 2; i; i -- ) down(i);</code></pre><h4 id="一般哈希">一般哈希</h4><h5 id="拉链法">拉链法</h5><pre><code class="language-cpp">int h[N], e[N], ne[N], idx;// 向哈希表中插入一个数void insert(int x)&#123;    int k = (x % N + N) % N;    e[idx] = x;    ne[idx] = h[k];    h[k] = idx ++ ;&#125;// 在哈希表中查询某个数是否存在bool find(int x)&#123;    int k = (x % N + N) % N;    for (int i = h[k]; i != -1; i = ne[i])        if (e[i] == x)            return true;    return false;&#125;</code></pre><h5 id="开放寻址法">开放寻址法</h5><pre><code class="language-cpp">int h[N];// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置int find(int x)&#123;    int t = (x % N + N) % N;    while (h[t] != null &amp;&amp; h[t] != x)    &#123;        t ++ ;        if (t == N) t = 0;    &#125;    return t;&#125;</code></pre><h3 id="高精度">高精度</h3><ul><li>高精度加法</li></ul><pre><code class="language-cpp">// C = A + B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    if (A.size() &lt; B.size()) return add(B, A);    vector&lt;int&gt; C;    int t = 0;    for (int i = 0; i &lt; A.size(); i ++ )    &#123;        t += A[i];        if (i &lt; B.size()) t += B[i];        C.push_back(t % 10);        t /= 10;    &#125;    if (t) C.push_back(t);    return C;&#125;</code></pre><ul><li>高精度减法</li></ul><pre><code class="language-cpp">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;    for (int i = 0, t = 0; i &lt; A.size(); i ++ )    &#123;        t = A[i] - t;        if (i &lt; B.size()) t -= B[i];        C.push_back((t + 10) % 10);        if (t &lt; 0) t = 1;        else t = 0;    &#125;    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();    return C;&#125;</code></pre><ul><li>高精度乘低精度</li></ul><pre><code class="language-cpp">// C = A * b, A &gt;= 0, b &gt;= 0vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)&#123;    vector&lt;int&gt; C;    int t = 0;    for (int i = 0; i &lt; A.size() || t; i ++ )    &#123;        if (i &lt; A.size()) t += A[i] * b;        C.push_back(t % 10);        t /= 10;    &#125;    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();    return C;&#125;</code></pre><ul><li>FFT多项式乘法</li></ul><p>保证输入中的系数大于等于 0 且小于等于 9</p><p>求F(x) 和 G(x) 的卷积</p><p>从低到高表示系数。</p><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 300010;const double PI = acos(-1);int n, m;struct Complex&#123;    double x, y;    Complex operator+ (const Complex&amp; t) const    &#123;        return &#123;x + t.x, y + t.y&#125;;    &#125;    Complex operator- (const Complex&amp; t) const    &#123;        return &#123;x - t.x, y - t.y&#125;;    &#125;    Complex operator* (const Complex&amp; t) const    &#123;        return &#123;x * t.x - y * t.y, x * t.y + y * t.x&#125;;    &#125;&#125;a[N], b[N];int rev[N], bit, tot;void fft(Complex a[], int inv)&#123;    for (int i = 0; i &lt; tot; i ++ )        if (i &lt; rev[i])            swap(a[i], a[rev[i]]);    for (int mid = 1; mid &lt; tot; mid &lt;&lt;= 1)    &#123;        auto w1 = Complex(&#123;cos(PI / mid), inv * sin(PI / mid)&#125;);        for (int i = 0; i &lt; tot; i += mid * 2)        &#123;            auto wk = Complex(&#123;1, 0&#125;);            for (int j = 0; j &lt; mid; j ++, wk = wk * w1)            &#123;                auto x = a[i + j], y = wk * a[i + j + mid];                a[i + j] = x + y, a[i + j + mid] = x - y;            &#125;        &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 0; i &lt;= n; i ++ ) scanf(&quot;%lf&quot;, &amp;a[i].x);    for (int i = 0; i &lt;= m; i ++ ) scanf(&quot;%lf&quot;, &amp;b[i].x);    while ((1 &lt;&lt; bit) &lt; n + m + 1) bit ++;    tot = 1 &lt;&lt; bit;    for (int i = 0; i &lt; tot; i ++ )        rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (bit - 1));    fft(a, 1), fft(b, 1);    for (int i = 0; i &lt; tot; i ++ ) a[i] = a[i] * b[i];    fft(a, -1);    for (int i = 0; i &lt;= n + m; i ++ )        printf(&quot;%d &quot;, (int)(a[i].x / tot + 0.5));    return 0;&#125;</code></pre><ul><li>高精度乘高精度</li></ul><pre><code class="language-cpp">    #include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 300000;const double PI = acos(-1);struct Complex&#123;    double x, y;    Complex operator+ (const Complex&amp; t) const    &#123;        return &#123;x + t.x, y + t.y&#125;;    &#125;    Complex operator- (const Complex&amp; t) const    &#123;        return &#123;x - t.x, y - t.y&#125;;    &#125;    Complex operator* (const Complex&amp; t) const    &#123;        return &#123;x * t.x - y * t.y, x * t.y + y * t.x&#125;;    &#125;&#125;a[N], b[N];char s1[N], s2[N];int res[N];int rev[N], bit, tot;void fft(Complex a[], int inv)&#123;    for (int i = 0; i &lt; tot; i ++ )        if (i &lt; rev[i])            swap(a[i], a[rev[i]]);    for (int mid = 1; mid &lt; tot; mid *= 2)    &#123;        auto w1 = Complex(&#123;cos(PI / mid), inv * sin(PI / mid)&#125;);        for (int i = 0; i &lt; tot; i += mid * 2)        &#123;            auto wk = Complex(&#123;1, 0&#125;);            for (int j = 0; j &lt; mid; j ++, wk = wk * w1)            &#123;                auto x = a[i + j], y = wk * a[i + j + mid];                a[i + j] = x + y, a[i + j + mid] = x - y;            &#125;        &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%s%s&quot;, s1, s2);    int n = strlen(s1) - 1, m = strlen(s2) - 1;    for (int i = 0; i &lt;= n; i ++ ) a[i].x = s1[n - i] - '0';    for (int i = 0; i &lt;= m; i ++ ) b[i].x = s2[m - i] - '0';    while ((1 &lt;&lt; bit) &lt; n + m + 1) bit ++ ;    tot = 1 &lt;&lt; bit;    for (int i = 0; i &lt; tot; i ++ )        rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1)) | ((i &amp; 1) &lt;&lt; (bit - 1));    fft(a, 1), fft(b, 1);    for (int i = 0; i &lt; tot; i ++ ) a[i] = a[i] * b[i];    fft(a, -1);    int k = 0;    for (int i = 0, t = 0; i &lt; tot || t; i ++ )    &#123;        t += a[i].x / tot + 0.5;        res[k ++ ] = t % 10;        t /= 10;    &#125;    while (k &gt; 1 &amp;&amp; !res[k - 1]) k -- ;    for (int i = k - 1; i &gt;= 0; i -- ) printf(&quot;%d&quot;, res[i]);    return 0;&#125;</code></pre><ul><li>高精度除以低精度</li></ul><pre><code class="language-cpp">// A / b = C ... r, A &gt;= 0, b &gt; 0vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123;    vector&lt;int&gt; C;    r = 0;    for (int i = A.size() - 1; i &gt;= 0; i -- )    &#123;        r = r * 10 + A[i];        C.push_back(r / b);        r %= b;    &#125;    reverse(C.begin(), C.end());    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();    return C;&#125;</code></pre><h3 id="随机化算法">随机化算法</h3><h4 id="模拟退火">模拟退火</h4><p>求n个点的欧氏距离中心点</p><pre><code>#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#define x first#define y secondusing namespace std;typedef pair&lt;double, double&gt; PDD;const int N = 110;int n;PDD q[N];double ans = 1e8;double rand(double l, double r)&#123;    return (double)rand() / RAND_MAX * (r - l) + l;&#125;double get_dist(PDD a, PDD b)&#123;    double dx = a.x - b.x;    double dy = a.y - b.y;    return sqrt(dx * dx + dy * dy);&#125;double calc(PDD p)&#123;    double res = 0;    for (int i = 0; i &lt; n; i ++ )        res += get_dist(p, q[i]);    ans = min(ans, res);    return res;&#125;void simulate_anneal()&#123;    PDD cur(rand(0, 10000), rand(0, 10000));    for (double t = 1e4; t &gt; 1e-4; t *= 0.9)    &#123;        PDD np(rand(cur.x - t, cur.x + t), rand(cur.y - t, cur.y + t));        double dt = calc(np) - calc(cur);        if (exp(-dt / t) &gt; rand(0, 1)) cur = np;    &#125;&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%lf%lf&quot;, &amp;q[i].x, &amp;q[i].y);    for (int i = 0; i &lt; 100; i ++ ) simulate_anneal();    printf(&quot;%.0lf\n&quot;, ans);    return 0;&#125;</code></pre><h4 id="爬山法">爬山法</h4><p>已知n+1球面上点求n维球球心</p><pre><code>#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 15;int n;double d[N][N];double ans[N], dist[N], delta[N];void calc()&#123;    double avg = 0;    for (int i = 0; i &lt; n + 1; i ++ )    &#123;        dist[i] = delta[i] = 0;        for (int j = 0; j &lt; n; j ++ )            dist[i] += (d[i][j] - ans[j]) * (d[i][j] - ans[j]);        dist[i] = sqrt(dist[i]);        avg += dist[i] / (n + 1);    &#125;    for (int i = 0; i &lt; n + 1; i ++ )        for (int j = 0; j &lt; n; j ++ )            delta[j] += (dist[i] - avg) * (d[i][j] - ans[j]) / avg;&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 0; i &lt; n + 1; i ++ )        for (int j = 0; j &lt; n; j ++ )        &#123;            scanf(&quot;%lf&quot;, &amp;d[i][j]);            ans[j] += d[i][j] / (n + 1);        &#125;    for (double t = 1e4; t &gt; 1e-6; t *= 0.99995)    &#123;        calc();        for (int i = 0; i &lt; n; i ++ )            ans[i] += delta[i] * t;    &#125;    for (int i = 0; i &lt; n; i ++ ) printf(&quot;%.3lf &quot;, abs(ans[i]));    return 0;&#125;</code></pre><h3 id="库">库</h3><h4 id="bitset">bitset</h4><pre><code class="language-cpp">bitset&lt;10000&gt; s;count()  返回有多少个1any()  判断是否至少有一个1none()  判断是否全为0set()  把所有位置成1set(k, v)  将第k位变成vreset()  把所有位变成0flip()  等价于~flip(k) 把第k位取反</code></pre><h4 id="rope">rope</h4><h5 id="导入">导入</h5><p>STL 中的 <code>rope</code> 采用可持久化平衡树实现，可完成随机访问和插入、删除元素的操作。。</p><p>可以使用如下方法来引入：</p><pre><code class="language-cpp">#include &lt;ext/rope&gt;using namespace __gnu_cxx;</code></pre><h5 id="基本操作">基本操作</h5><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>rope &lt;int &gt; a</code></td><td style="text-align:center">初始化 <code>rope</code>（与 <code>vector</code> 等容器很相似）</td></tr><tr><td style="text-align:center"><code>a.push_back(x)</code></td><td style="text-align:center">在 <code>a</code> 的末尾添加元素 <code>x</code></td></tr><tr><td style="text-align:center"><code>a.insert(pos, x)</code></td><td style="text-align:center">在 <code>a</code> 的 <code>pos</code> 个位置添加元素 <code>x</code></td></tr><tr><td style="text-align:center"><code>a.erase(pos, x)</code></td><td style="text-align:center">在 <code>a</code> 的 <code>pos</code> 个位置删除 <code>x</code> 个元素</td></tr><tr><td style="text-align:center"><code>a.at(x)</code> 或 <code>a[x]</code></td><td style="text-align:center">访问 <code>a</code> 的第 <code>x</code> 个元素</td></tr><tr><td style="text-align:center"><code>a.length()</code> 或 <code>a.size()</code></td><td style="text-align:center">获取 <code>a</code> 的大小</td></tr></tbody></table><h4 id="priority-queue">priority_queue</h4><pre><code class="language-cpp">#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace __gnu_pbds;__gnu_pbds ::priority_queue&lt;T, Compare, Tag, Allocator&gt;</code></pre><h5 id="模板形参">模板形参</h5><ul><li><code>T</code>: 储存的元素类型</li><li><code>Compare</code>: 提供严格的弱序比较类型</li><li><code>Tag</code>: 是 <code>__gnu_pbds</code> 提供的不同的五种堆，Tag 参数默认是 <code>pairing_heap_tag</code> 五种分别是：<ul><li><code>pairing_heap_tag</code>：配对堆<br>官方文档认为在非原生元素（如自定义结构体/<code>std :: string</code>/<code>pair</code>）中，配对堆表现最好</li><li><code>binary_heap_tag</code>：二叉堆<br>官方文档认为在原生元素中二叉堆表现最好，不过笔者测试的表现并没有那么好</li><li><code>binomial_heap_tag</code>：二项堆<br>二项堆在合并操作的表现要优于二叉堆，但是其取堆顶元素操作的复杂度比二叉堆高</li><li><code>rc_binomial_heap_tag</code>：冗余计数二项堆</li><li><code>thin_heap_tag</code>：除了合并的复杂度都和 Fibonacci 堆一样的一个 tag</li></ul></li></ul><p>经作者本机 Core i5 @3.1 GHz On macOS 测试堆的基础操作，结合 GNU 官方的复杂度测试，Dijkstra 测试，都表明：<br>至少对于 OIer 来讲，除了配对堆的其他四个 tag 都是鸡肋，要么没用，要么常数大到不如 <code>std</code> 的，且有可能造成 MLE，故这里 <strong>只推荐用默认的配对堆</strong> 。同样，配对堆也优于 <code>algorithm</code> 库中的 <code>make_heap()</code>。</p><h5 id="构造方式">构造方式</h5><p>要注明命名空间因为和 <code>std</code> 的类名称重复。</p><pre><code class="language-cpp">__gnu_pbds ::priority_queue&lt;int&gt; __gnu_pbds::priority_queue&lt;int, greater&lt;int&gt; &gt;__gnu_pbds ::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt;__gnu_pbds ::priority_queue&lt;int&gt;::point_iterator id; // 点类型迭代器// 在 MODify 和 push 的时候都会返回一个 point_iteratorid = q.push(1);</code></pre><h5 id="成员函数">成员函数</h5><ul><li><code>push()</code>: 向堆中压入一个元素，返回该元素位置的迭代器。</li><li><code>pop()</code>: 将堆顶元素弹出。</li><li><code>top()</code>: 返回堆顶元素。</li><li><code>size()</code> 返回元素个数。</li><li><code>empty()</code> 返回是否非空。</li><li><code>MODify(point_iterator, const key)</code>: 把迭代器位置的 <code>key</code> 修改为传入的 <code>key</code>，并对底层储存结构进行排序。</li><li><code>erase(point_iterator)</code>: 把迭代器位置的键值从堆中擦除。</li><li><code>join(__gnu_pbds :: priority_queue &amp;other)</code>: 把 <code>other</code> 合并到 <code>*this</code> 并把 <code>other</code> 清空。</li></ul><p>使用的 tag 决定了每个操作的时间复杂度：</p><table><thead><tr><th></th><th>push</th><th style="text-align:left">pop</th><th>MODify</th><th>erase</th><th>Join</th></tr></thead><tbody><tr><td><code>pairing_heap_tag</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:left">最坏<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 均摊 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></td><td>最坏<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 均摊 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></td><td>最坏<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 均摊 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td></tr><tr><td><code>binary_heap_tag</code></td><td>最坏<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 均摊 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></td><td style="text-align:left">最坏<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 均摊 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr><tr><td><code>binomial_heap_tag</code></td><td>最坏<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span> 均摊 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></td></tr><tr><td><code>rc_binomial_heap_tag</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></td></tr><tr><td><code>thin_heap_tag</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:left">最坏<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 均摊 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></td><td>最坏<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span> 均摊 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td>最坏<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 均摊 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr></tbody></table><h4 id="tree">tree</h4><pre><code class="language-cpp">#include &lt;ext/pb_ds/assoc_container.hpp&gt;  // 因为tree定义在这里 所以需要包含这个头文件#include &lt;ext/pb_ds/tree_policy.hpp&gt;using namespace __gnu_pbds;__gnu_pbds ::tree&lt;Key, Mapped, Cmp_Fn = std::less&lt;Key&gt;, Tag = rb_tree_tag,                  Node_Update = null_tree_node_update,                  Allocator = std::allocator&lt;char&gt; &gt;</code></pre><ul><li><p>模板形参</p><ul><li><code>Key</code>: 储存的元素类型，如果想要存储多个相同的 <code>Key</code> 元素，则需要使用类似于 <code>std::pair</code> 和 <code>struct</code> 的方法，并配合使用 <code>lower_bound</code> 和 <code>upper_bound</code> 成员函数进行查找</li><li><code>Mapped</code>: 映射规则（Mapped-Policy）类型，如果要指示关联容器是 <strong>集合</strong>，类似于存储元素在 <code>std::set</code> 中，此处填入 <code>null_type</code>，低版本 <code>g++</code> 此处为 <code>null_mapped_type</code>；如果要指示关联容器是 <strong>带值的集合</strong>，类似于存储元素在 <code>std::map</code> 中，此处填入类似于 <code>std::map&lt;Key, Value&gt;</code> 的 <code>Value</code> 类型</li><li><code>Cmp_Fn</code>: 关键字比较函子，例如 <code>std::less&lt;Key&gt;</code></li><li><code>Tag</code>: 选择使用何种底层数据结构类型，默认是 <code>rb_tree_tag</code>。<code>__gnu_pbds</code> 提供不同的三种平衡树，分别是：<ul><li><code>rb_tree_tag</code>：红黑树，一般使用这个，后两者的性能一般不如红黑树</li><li><code>splay_tree_tag</code>：splay 树</li><li><code>ov_tree_tag</code>：有序向量树，只是一个由 <code>vector</code> 实现的有序结构，类似于排序的 <code>vector</code> 来实现平衡树，性能取决于数据想不想卡你</li></ul></li><li><code>Node_Update</code>：用于更新节点的策略，默认使用 <code>null_node_update</code>，若要使用 <code>order_of_key</code> 和 <code>find_by_order</code> 方法，需要使用 <code>tree_order_statistics_node_update</code></li></ul></li><li><p>构造方式</p></li></ul><pre><code class="language-c++">__gnu_pbds::tree&lt;std::pair&lt;int, int&gt;, __gnu_pbds::null_type,                 std::less&lt;std::pair&lt;int, int&gt; &gt;, __gnu_pbds::rb_tree_tag,                 __gnu_pbds::tree_order_statistics_node_update&gt;    trr;</code></pre><ul><li><p>成员函数</p><ul><li><code>insert(x)</code>：向树中插入一个元素 x，返回 <code>std::pair&lt;point_iterator, bool&gt;</code>。</li><li><code>erase(x)</code>：从树中删除一个元素/迭代器 x，返回一个 <code>bool</code> 表明是否删除成功。</li><li><code>order_of_key(x)</code>：返回 x 以 <code>Cmp_Fn</code> 比较的排名。</li><li><code>find_by_order(x)</code>：返回 <code>Cmp_Fn</code> 比较的排名所对应元素的迭代器。</li><li><code>lower_bound(x)</code>：以 <code>Cmp_Fn</code> 比较做 <code>lower_bound</code>，返回迭代器。</li><li><code>upper_bound(x)</code>：以 <code>Cmp_Fn</code> 比较做 <code>upper_bound</code>，返回迭代器。</li><li><code>join(x)</code>：将 x 树并入当前树，前提是两棵树的类型一样，x 树被删除。</li><li><code>split(x,b)</code>：以 <code>Cmp_Fn</code> 比较，小于等于 x 的属于当前树，其余的属于 b 树。</li><li><code>empty()</code>：返回是否为空。</li><li><code>size()</code>：返回大小。</li></ul></li></ul><h3 id="Sanitizer">Sanitizer</h3><p>理智保证器。在运行时检查你的程序是否有未定义行为、数组越界、空指针，等等功能。<br>这些 sanitizer 绝大多数可以在 GCC 和 Clang 中使用。sanitizer 在 llVM 中更加成熟，因此推荐本地使用 Clang 编译器进行相关除错。</p><h4 id="Address-Sanitizer-fsanitize-address">Address Sanitizer -fsanitize=address</h4><p>GCC 和 Clang 都支持这个 Sanitizer。包括如下检查项：</p><ul><li>越界</li><li>释放后使用 (use-after-free)</li><li>返回后使用 (use-after-return)</li><li>重复释放 (double-free)</li><li>内存泄漏 (memory-leaks)</li><li>离开作用域后使用  (use-after-scope)</li></ul><p>应用这项检查会让你的程序慢 2x 左右。</p><h4 id="Undefined-Behavior-Sanitizer-fsanitize-undefined">Undefined Behavior Sanitizer -fsanitize=undefined</h4><p>Undefined Behavior Sanitizer 用于检查代码中的未定义行为。GCC 和 Clang 都支持这个 Sanitizer。自动检查你的程序有无未定义行为。UBSan 的检查项目包括：</p><ul><li>位运算溢出，例如 32 位整数左移 72 位</li><li>有符号整数溢出</li><li>浮点数转换到整数数据溢出</li></ul><p>UBSan 的检查项可选。</p><h3 id="TODOLIST">TODOLIST</h3><p>//字符串–AC自动机等</p><p>//完全体并查集</p><p>//离线LCA</p><p>//splay</p><p>//网络流</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/1243066710.html"/>
      <url>/posts/1243066710.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><pre><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><pre><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><pre><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><pre><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
